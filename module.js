"use strict";

var events = require('events');
var messageContext = require('./messageContext.js');
var rx = require('rx');
var util = require('util');

/**
 * Provides functionality for creating and interacting with micro-services.
 *
 * @module medseek-util-microservices
 */

util.inherits(MicroServicesModule, events.EventEmitter);
function MicroServicesModule(opts) {
    events.EventEmitter.call(this);

    var isDisposed = false;
    var serializer = undefined;
    var toDispose = [];
    var transport = undefined;

    this.options = opts || (opts = {
        /**
         * Gets or sets a value indicating whether debug information should be
         * generated by the micro-services module.
         * @type {boolean}
         */
        debug: false
    });

    Object.defineProperty(this, 'transport', { get: function() { return transport; } });

    this.useSerializer = function(value) {
        serializer = value;
    };

    this.useTransport = function(value, options) {
        if (transport)
            throw new Error('Use of multiple transports is not supported.');
        if (value instanceof Function) {
            options = options || {};
            if (!options.debug && options.debug !== false)
                options.debug = opts.debug;
            opts.debug = options.debug;
            value = new value(options);
        }

        debug('addTransport', 'Using transport: ' + value.name);
        var disposable = rx.Disposable.create(disposeTransport);
        process.on('SIGINT', function() {
            disposeTransport();
            process.exit();
        });
        function disposeTransport() {
            if (transport === value)
                transport = undefined;
            value.stop();
        }
        transport = value;
        toDispose.push(disposable);

        setImmediate(value.start);
        return disposable;
    };

    this.bind = function(address, action) {
        var subject = new rx.Subject();
        var callback = function(x) {
            debug('bind.onNext', 'Received: ' + x);
            updateMessageContext(x);
            if (action) {
                var replied;
                if (x.reply) {
                    var originalReply = x.reply;
                    x.reply = function(body, properties) {
                        replied = true;
                        debug('bind.onNext.reply', 'Sending reply; body = ' + result);
                        originalReply(body, properties);
                    };
                }
                var result = action(x);
                if (x.reply && !replied && result)
                    x.reply(result);
                else if (result)
                    me.emit('error', new Error('Cannot send reply.'), x, result);
            }
            subject.onNext(x);
        };

        debug('bind', 'Trying transport: ' + transport.name + '');
        return transport.bind(address, callback)
            .then(function(descriptor) {
                if (!descriptor)
                    throw new Error('No transport was able to bind the endpoint ' + address + '.');

                debug('bind', 'Bound transport: ' + transport.name + '\n');
                return subject;
            });
    };

this.bindReply = function(replyAction) {
        var subject = new rx.Subject();
        var callback = function(x, replyContext) {
            debug('bindReply.onNext', 'Received: ' + x);
            updateMessageContext(x);
            if (replyAction) {
                var replied;
                if (x.reply) {
                    var originalReply = x.reply;
                    x.reply = function(body, properties) {
                        replied = true;
                        debug('bindReply.onNext.reply', 'Sending reply; body = ' + result);
                        originalReply(body, properties);
                    };
                }
                var result = replyAction(x, replyContext);
                if (x.reply && !replied && result)
                    x.reply(result);
                else if (result)
                    me.emit('error', new Error('Cannot send reply.'), x, result);
            }
            subject.close = replyContext.close;
            subject.send = replyContext.send;
            subject.onNext(x);
        };

        return transport.bindReply(callback)
            .then(function(replyContext) {
                if (!replyContext)
                    throw new Error('No transport was able to bind the reply endpoint.');

                subject.close = replyContext.close;
                subject.send = replyContext.send;
                return subject;
            });
    };

    this.send = function(address, body, properties) {
        return transport.send.apply(transport, arguments);
    };

    this.dispose = function dispose() {
        if (!isDisposed) {
            isDisposed = true;
            toDispose.forEach(function(x) { x.dispose(); });
            toDispose.splice(0, toDispose.length);
        }
    };

    function debug(label, value) {
        if (opts.debug) {
            var text = '[medseek-util-microservices.' + label + '] ' + value;
            util.debug(text);
        }
    }

    function updateMessageContext(x) {
        var serializer = serializer || (serializer = require('./serializer'));
        x.deserialize = serializer.deserialize.bind(serializer, (x.properties || {}).contentType, x.body);
    }
}

var me = new MicroServicesModule();

/**
 * Provides access to options that can be used to configure the micro-services
 * module before it is initialized.
 */
module.exports.options = me.options;

/**
 * Adds a new listener for the specified event.
 *
 * @type {function(this:MicroServicesModule)|*}
 */
module.exports.on = me.on.bind(me);

/**
 * A transport for the micro-services module that interacts with an AMQP
 * service.
 *
 * @constructor
 * @api public
 */
Object.defineProperty(module.exports, 'AmqpTransport', {
    get: function() {
        return require('./transport-amqp.js');
    }
});

Object.defineProperty(module.exports, 'transport', {
    get: function() {
        return me.transport;
    }
});


/**
 * Sets up a serializer for use by the micro-services module.
 *
 * @param serializer The serializer object.
 * @api public
 */
module.exports.useSerializer = me.useSerializer.bind(me);

/**
 * Sets up a transport for use by the micro-services module.
 *
 * @param transport The transport object or constructor.
 * @param [options] The options to provide to the transport if it is specified by constructor.
 * @return Rx.IDisposable that removes the transport from further use when dispose is invoked.
 * @api public
 */
module.exports.useTransport = me.useTransport.bind(me);

/**
 * Binds a micro-service endpoint at the specified address.
 *
 * @param address Describes the endpoint addresses.
 * @param [action] A function to invoke for incoming messages.
 * @return {rx.Observable<messageContext.MessageContext>} An observable stream of messages received at the endpoint.
 * @api public
 */
module.exports.bind = me.bind.bind(me);

/**
 * Binds a reply endpoint for use with the specified action.
 *
 * @param action An action to be invoked with the reply context.
 * @param [replyAction] A function to invoke for incoming reply messages.
 * @return An observable stream of messages received at the endpoint.
 * @api public
 */
module.exports.bindReply = me.bindReply.bind(me);

/**
 * Sends a message to the specified endpoint.
 *
 * @param {string} address The address of the destination endpoint.
 * @param {Object} body The message body.
 * @param {Object} [properties] Additional message properties.
 * @api public
 */
module.exports.send = me.send.bind(me);

/**
 * Shuts down the micro-services module components.
 *
 * @api public
 */
module.exports.dispose = me.dispose.bind(me);